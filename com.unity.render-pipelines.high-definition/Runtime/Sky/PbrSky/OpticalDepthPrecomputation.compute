#pragma enable_d3d11_debug_symbols
#pragma only_renderers d3d11 ps4 xboxone vulkan metal switch
#pragma kernel main

#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Sky/PbrSky/PbrSkyCommon.hlsl"

#define sec(x) rcp(cos(x))
#define TABLE_SIZE float2(PBRSKYCONFIG_OPTICAL_DEPTH_TABLE_SIZE_X, PBRSKYCONFIG_OPTICAL_DEPTH_TABLE_SIZE_Y)

RW_TEXTURE2D(float2, _OpticalDepthTable); // of TABLE_SIZE

// For (chi == Pi/2).
float ChapmanHorizontal(float x)
{
    float r = rsqrt(x);
    float s = x * r; // sqrt(x)

    return 1.2534 * s + 0.467 * r;
}

// For (chi < Pi/2).
float ChapmanUpper(float x, float chi)
{
    float a = 3.88 * pow(abs(x), -1.143);
    float b = 1.0123 - 1.454 * rsqrt(x);
    float c = sec(b * chi) - 0.834;
    float d = a * c;

    return sec(chi - d);
}

// Requirements: (x > 0).
// We use the following approximation:
// "An approximate form for the Chapman grazing incidence function" by Titheridge, J. E.
// TODO: consider Christian Schueler's cheaper approximation.
float ChapmanFunction(float x, float chi)
{
    bool useIdentity = chi > HALF_PI;

    if (useIdentity)
    {
        chi = PI - chi;
    }

    float cu = ChapmanUpper(x, chi);

    if (useIdentity)
    {
        float z = x * sin(chi);
        float r = rsqrt(z);
        float s = z * r; // sqrt(z)
        float a = exp(x - z);
        float b = 2.507 * s + 0.934 * r;

        return a * b - cu;
    }
    else
    {
        return cu;
    }
}

[numthreads(8, 8, 1)]
void main(uint2 dispatchThreadId : SV_DispatchThreadID)
{
    const float2 scale = rcp(TABLE_SIZE);
    const float2 bias  = 0.5 * scale;

    // Let the hardware and the driver handle the ordering of the computation.
    uint2 tableCoord = dispatchThreadId;

    // We don't care about the extremal points (boundary values).
    float2 uv = tableCoord * scale + bias;

    float height = UnmapAerialPerspective(uv).x;
    float cosChi = UnmapAerialPerspective(uv).y;
    float chi    = acos(cosChi);

    float R = _PlanetaryRadius;
    float h = height;
    float r = R + h;

    float2 S = float2(_AirScaleHeight,    _AerosolScaleHeight);
    float2 F = float2(_AirDensityFalloff, _AerosolDensityFalloff);

    // Now we need to compute the optical depth along the ray.
    // It is given as the integral of the atmospheric thickness (extinction) along the ray.
    //
    // AirThickness[h]         = AirThickness[0]     * Exp[-h / airS]
    // AerosolThickness[h]     = AerosolThickness[0] * Exp[-h / aerosolS]
    // AtmosphericThickness[h] = AirThickness[h] + AerosolThickness[h]
    //
    // For now, assume that no intersection with the planet occurred.
    //
    // OpticalDepth = Integrate[Extinction[t], {t, 0, Infinity}]
    // OpticalDepth = Integrate[Thickness[0] * Exp[-h[t] / S], {t, 0, Infinity}]
    // OpticalDepth = Thickness[0] * Integrate[Exp[-h[t] / S], {t, 0, Infinity}]
    // OpticalDepth = Thickness[0] * Integrate[Exp[(R - Sqrt[(r * Sin[chi])^2 + t^2]) / S], {t, r * Cos[chi], Infinity}]
    // OpticalDepth = Thickness[0] * S * Exp[(R - r) / S] * Integrate[Exp[(r - Sqrt[(r * Sin[chi])^2 + t^2]) / S] / S, {t, r * Cos[chi], Infinity}]
    // By defining (x = r / S) and (s = t / S), we get:
    // OpticalDepth = Thickness[0] * S * Exp[(R - r) / S] * Integrate[Exp[x - Sqrt[(x * Sin[chi])^2 + s^2]], {s, x * Cos[chi], Infinity}]
    // OpticalDepth = Thickness[0] * S * Exp[(R - r) / S] * Integrate[Exp[x - Sqrt[s^2 + 2 * s * (x * Cos[chi]) + x^2]], {s, 0, Infinity}]
    // OpticalDepth = Thickness[0] * S * Exp[(R - r) / S] * ChapmanFunction[x, chi]
    //
    // For more information, see the article by Christian Schueler titled
    // "Approximation to the Chapman Grazing-Incidence Function for Atmospheric Scattering".
    //
    // To save on the storage, we will scale by sea level thickness at runtime.

    float2 tableEntry;

    tableEntry.x = S.x * exp(-h * F.x) * ChapmanFunction(r * F.x, chi);
    tableEntry.y = S.y * exp(-h * F.y) * ChapmanFunction(r * F.y, chi);

    _OpticalDepthTable[tableCoord] = tableEntry;
}
